# Ch06 - 浮點數
## 聲明浮點變數
只要數字含有小數部分，他的類型就是 float64，如果一個整數要初始化某個變數，要指定他的類型為 float64 ，否則他會是一個整數類型。
```go=
kirito1 := 87.63
var kirito2 = 87.63
var kirito3 float64 = 87.63
fmt.Println(kirito1, kirito2, kirito3)
// 三個變數都是一樣的 87.63 87.63 87.63
```

## 單精度浮點數
Golang 裡有兩種浮點數類型：
**float64**
* 64 位的浮點類型
* 占用 8 bytes
* 某些語言稱為 double（倍精度）

**float32**
* 占用 4 bytes
* 精度比 float64 低
* 又稱單精度類型

如果想使用單精度類型的話，必須在聲明變數的時候指定為 float32 ，否則預設為 float64
```go=
pi64 := math.Pi
pi32 := float32(math.Pi)
fmt.Println(pi64)    // 3.141592653589793
fmt.Println(pi32)    // 3.1415927
```

### 使用場景
處理大量數據，如 3D 遊戲包含數千個頂點，使用 float32 犧牲精度來節省內存<br>
math 包內的函數操作都是 float64 類型，所以首選使用 float64 ，除非必要，不然沒有足夠的理由去使用 float32

## 零值
Golang 內每個類型都有一個默認值，他稱為零值
聲明變數時不對他進行初始化，他的值就會是零值
```go=
var kirito float64
fmt.Println("kirito:=", kirito)    // kirito:= 0
```

## 顯示浮點數類型
使用 Print 或 Printf 輸出浮點數時，默認是盡可能的顯示多位小數<br>
如果想顯示固定位數的浮點數時，可以使用 Printf ，結合 %f 格式化動詞來指定顯示浮點數的位數
```go=
kirito :=1.0 / 3
fmt.Println(kirito)    // 0.3333333333333333
fmt.Printf("%f\n", kirito)    // 0.333333
fmt.Printf("%.2f\n", kirito)    // 0.33
fmt.Printf("%4.2f", kirito)    // 0.33 不滿足 4 位則補 0
```

## 浮點數類型的精度
```go=
num := .1
num += .2
fmt.Println(num)    // 0.30000000000000004

celsius := 21.0
fmt.Println((celsius / 5.0 * 9.0) + 32)    // 69.80000000000001
fmt.Println((9.0 / 5.0 * celsius) + 32)    // 69.80000000000001

fmt.Print((celsius * 9.0 / 5.0) + 32.0)    // 69.8
```
浮點數類型不適合用於金融類計算<br>
為了盡量將錯誤最小化，建議先做乘法，在做除法

## 編寫一個程式
隨機將五分鎳幣（0.05 美金）、一角硬幣（0.10 美金）和 25 分美分硬幣（0.25 美元），放入一個空的儲蓄罐，直到內含 20 美元。
* 每次存款顯示儲蓄罐的金額
* 以適當的寬度和精度格式化