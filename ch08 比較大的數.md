# Ch08 - 比較大的數
## 數太大了怎麼辦？
浮點類型可以儲存非常大的數，但是精度不高<br>
整數類型精度高，但是取值的範圍有限<br>
如果需要很大的數，且精度要很精確可以使用 **`int64`** ，如果不夠，<br>
可以使用 **`uint64`** 無符號整數，可以容納更多的正數，如果不夠，<br>
可以使用浮點數湊合著用，但是如果不要使用浮點數，可以使用， Big 包<br>
如果沒有為指數形式的數值指定類型的話，Golang 則會將它視為 **`float64`**
```go=
var num int64 = 87e63
fmt.Print(num)	// overflows int64

var num uint64 = 87e63
fmt.Print(num)	// overflows uint64

var num float64 = 87e63
fmt.Print(num)	// 8.7e+64

var num = 87e63
fmt.Printf("%T", num)	// float64
```

## Big 包
對於較大的整數（超過 $10^{18}$）：big.Int<br>
對於任意精度的浮點類型：big.Float<br>
對於分數：big.Rat

### big.Int
一旦使用 **big.Int** 那麼等式其他部分也必須使用 **big.Int**<br>
NewInt() 函式可以將 int64 轉化為 big.Int 類型<br>
如果超過 int64 的最大值，可以先 new 一個 big.Int 再透過 SetString 函式把數值的字符串，和多進制進行傳遞即可<br>
缺點：使用起來比較複雜，且速度慢
```go=
bigInt := big.NewInt(2147483647)
fmt.Print(bigInt)		// 2147483647

bigNumber := new(big.Int)
bigNumber.SetString("2147483648", 10)	// int64 最大值為 2147483647，10 為 10 進制
fmt.Print(bigNumber)	// 2147483648
```

## 較大數值的常數
在 Golang 當中，可為常數指定類型，也可以不指定常數的類型<br>
對於變數，Golang 會使用類型推斷<br>
常量也可以是無類型的（untyped）<br>
並且常數使用 **`const`** 來聲明，程式內每個字面值都是常數，這意味著比較大的數值可以直接使用（作為字面值）
```go=
fmt.Print("Andromeda Galaxy is ", 24000000000000000000/299792/86400, " light days away.")
// Andromeda Galaxy is 926568346 light days away.
```

針對字面值與常數的計算是在編譯階段就完成的<br>
這種無類型的數值字面值就是由 big 包所支持的，這使我們可以操作很大的數（超過 18 的 $10^{18}$）<br>
只要能夠容納下，那麼常數可以賦值給變數使用<br>
儘管是使用 big 包來處理無類型的數值常數，但是常數和 big,Int 的值是不能互換的


## 編寫一個程式
大矮星是目前已知距離地球最近的星系，距離我們的太陽 236000000000000000 公里，使用常量將此距離轉換為光年